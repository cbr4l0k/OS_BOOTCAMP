from enum import Enum
from typing import Any
from pydantic import BaseModel, Field


# ==================
# === Core Query ===
# ==================

class Query(BaseModel):
    content: str = Field(..., description="User request or refined step query.")


# ======================
# === Retrieved Data ===
# ======================

class SourceType(str, Enum):
    WEBPAGE = "webpage"
    SOCIAL = "social"
    ACADEMIC = "academic"
    FINANCIAL = "financial"
    DOCUMENT = "document"
    OTHER = "other"

class SourceProvider(str, Enum):
    SERP = "serp"
    REDDIT = "reddit"
    TWITTER = "twitter"
    VK = "vk"
    HABR = "habr"
    SCRAPER = "scraper"
    ACADEMIC = "academic"
    FINANCE = "finance"

class Source(BaseModel):
    """
    Represents a single piece of retrieved information,
    independent of where it came from or how it was fetched.
    """
    id: str = Field(..., description="Stable identifier for deduplication & citation.")
    provider: SourceProvider = Field(..., description="Which adapter produced this.")
    type: SourceType = Field(SourceType.OTHER, description="High-level category.")
    url: str | None = Field(None, description="Original URL if available.")
    title: str | None = Field(None, description="Title or short label.")
    excerpt: str | None = Field(None, description="Short text snippet or summary.")
    raw: dict[str, Any] = Field(
        default_factory=dict,
        description="Original retrieved fields (implementation-specific)."
    )
    metadata: dict[str, Any] = Field(
        default_factory=dict,
        description="Parsed metadata (timestamp, author, tagsâ€¦)."
    )


# ==============================================
# === Retrieval -> Verification -> Synthesis ===
# ==============================================

class RetrievedData(BaseModel):
    sources: list[Source] = Field(
        ...,
        description="List of structured evidence items retrieved from external systems."
    )

class VerifiedData(BaseModel):
    facts: dict[str, Any] = Field(..., description="Valid factual content.")
    confidence: float = Field(..., gt=0, lt=1, description="Confidence score between 0 and 1.")

    def to_formatted_string(self) -> str:
        """
        Convert verified facts into a nicely formatted string for LLM consumption.

        Returns:
            A formatted string representation of the facts
        """
        if not self.facts:
            return "No verified facts available."

        formatted_facts = []
        for key, value in self.facts.items():
            # Handle different value types
            if isinstance(value, dict):
                content = value.get('content', str(value))
            elif isinstance(value, list):
                content = "\n  ".join(f"- {item}" for item in value)
            else:
                content = str(value)

            formatted_facts.append(f"{key}:\n  {content}")

        return "\n\n".join(formatted_facts)

class SynthesisOutput(BaseModel):
    """
    Structured output schema for LLM synthesis.
    """
    reasoning: str = Field(..., description="Explanation or reasoning chain showing how the conclusion was derived.")
    conclusion: str = Field(..., description="Final distilled answer based on the verified facts.")

class StructuredAnswer(BaseModel):
    reasoning: str = Field(..., description="Explanation or reasoning chain.")
    conclusion: str = Field(..., description="Final distilled answer.")
    metadata: dict[str, Any] = Field(
        default_factory=dict,
        description="Optional additional structured info.",
    )


# =========================================
# === Agent State (for LangGraph steps) ===
# =========================================

class AgentState(BaseModel):
    # The current task/query being processed
    query: Query

    # Conversation history for interactive refinement
    conversation: list[str] = Field(
        default_factory=list,
        description="Chat messages exchanged with the user."
    )

    # Subtasks generated by decomposition
    tasks: list[Query] = Field(
        default_factory=list,
        description="List of decomposed tasks for Pro Mode."
    )
    current_task_index: int = Field(
        default=0,
        gt= 0,
        description="Pointer to current task in Pro Mode."
    )

    # Retrieval -> verification -> synthesis artifacts
    retrieved: RetrievedData | None = None
    verified: VerifiedData | None = None
    answer: StructuredAnswer | None = None

    # Multi-step reasoning iteration counter
    iteration: int = Field(default=0, description="Iteration number in the loop.")

    # Free-form memory for models and graph nodes
    memory: dict[str, Any] = Field(
        default_factory=dict,
        description="Open-ended memory for intermediate info or model outputs."
    )

    class Config:
        arbitrary_types_allowed = True
